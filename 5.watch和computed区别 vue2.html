<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
  <div id="app">
    {{fullName}}
  </div>
  <script>

  // Vue.compile用法
    let res = Vue.compile('<div><span>{{fullName}}</span></div>')
    new Vue({
      el: '#app',
      data: {
        fullName: 'zhang san',
      },
      render: res.render,
      staticRenderFns: res.staticRenderFns
    })


    // var vm = new Vue({
    //   el: '#app',
    //   data: {
    //     firstName: 'zhang',
    //     lastName: 'san'
    //   },
    //   watch: {
    //   },
    //   // 计算属性computed 会创建一个计算属性watcher，new Watcher({lazy: true}) ,lazy代表不会立刻执行，因为watcher是立即执行的 
    //   // 1.计算属性会创建一个计算属性watcher，这个watcher(lazy:true)不会立刻执行
    //   // 2.通过object.defineProperty将计算属性定义到实例上
    //   // 3.当用户取值时会触发getter，拿到计算属性对应的watcher，看dirty是否为true，如果为true则求值
    //   // 4.并且让计算属性watcher中依赖的属性收集最外层的渲染watcher，可以做到依赖的属性变化了，触发计算属性更新dirty并且可以触发页面更新
    //   // 5.如果计算属性的依赖的值没有发生变化，则采用缓存
    //   computed: {
    //     fullName: function () {
    //       return this.firstName + ' ' + this.lastName
    //     },
    //     fullName2: {
    //       get: function () {
    //         return this.firstName + ' ' + this.lastName
    //       },
    //       set: function (newVal) {
    //         var names = newVal.split(' ')
    //         this.firstName = names[0]
    //         this.lastName = names[names.length - 1]
    //       }
    //     }
    //   },
    //   mounted() {
    //     this.firstName = 'hu' // firstName收集了渲染watcher（模板），和计算属性watcher（fullName）
    //   },
    // })
  </script>
</body>
</html>